---
layout: post
title: 'Code Reading: "Firefox Send" encryption'
author: cat_in_136
tags:
- javascript
- encrypt
- web application
date: '2017-08-12T12:32:50+09:00'
---
<p>
Mozilla Test Pilot Team has released <a href="https://send.firefox.com/">Firefox Send</a>.
This post describes how safe Firefox Send is by reading code.
Note that <a href="https://blog.mozilla.org/blog/2017/08/01/new-test-pilot-experiments/">The team blog post announces the safety of their service</a>:
</p>

<blockquote cite="https://blog.mozilla.org/blog/2017/08/01/new-test-pilot-experiments/">
  <p>Your files are encrypted during transmission. Plus, <a href="https://www.youtube.com/watch?v=ZGWZGYtAS3U">Send</a> encrypts files on the client side, so that not even Mozilla can read them.</p>
</blockquote>

<h3 id="firefox_send_tldr">TL;DR</h3>

{% capture tldr %}
<p>As of <a href="https://github.com/mozilla/send/tree/v1.1.0">v1.1.0</a>,</p>
<ul>
  <li>File data is encrypted on the client side during uploading.</li>
  <li>File data is decrypted on the client side during downloading.</li>
  <li>File name is <em>not encrypted</em> and stored on the server.</li>
  <li>Secret Key is generated by the client side and shared with the sender/receiver persons by <em>hash (<code>#</code>) of the download link URL</em>. It is <em>never sent</em> to the server.</li>
</ul>
{% endcapture %}
{{ tldr }}

<h3 id="firefox_send_fileSender_upload">Client side: FileSender#upload()</h3>

<p>
This clause describes <code>FileSender#upload()</code> method defined in <a href="https://github.com/mozilla/send/blob/v1.1.0/frontend/src/fileSender.js">frontend/src/fileSender.js</a> (to upload with client-side encryption).
</p>

<h4 id="firefox_send_fileSender_upload_1">first Promise : Generate Key and Load File</h4>

<pre class="prettyprint"><code>    return Promise.all([
      window.crypto.subtle.generateKey(
        {
          name: 'AES-GCM',
          length: 128
        },
        true,
        ['encrypt', 'decrypt']
      ),
      new Promise((resolve, reject) =&gt; {
        const reader = new FileReader();
        reader.readAsArrayBuffer(this.file);
        reader.onload = function(event) {
          const plaintext = new Uint8Array(this.result);
          resolve(plaintext);
        };
        reader.onerror = function(err) {
          reject(err);
        };
      })
])
</code></pre>

<p>The first promise is resolved when both of following two procedures are completed:</p>
<ul>
  <li>Generate Key:
    <ul>
      <li>using <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey">generateKey()</a> of Web Crypto API;</li>
      <li>with a symmetric algorithm "AES-GCM" (AES in Galois/Counter Mode);</li>
      <li>with 128-bit key length.</li>
    </ul>
  </li>
  <li>Read file</li>
</ul>

<h4 id="firefox_send_fileSender_upload_2">second Promise : Encrypt and Export key</h4>

<pre class="prettyprint"><code>      .then(([secretKey, plaintext]) =&gt; {
        self.emit('encrypting');
        return Promise.all([
          window.crypto.subtle.encrypt(
            {
              name: 'AES-GCM',
              iv: this.iv,
              tagLength: 128
            },
            secretKey,
            plaintext
          ),
          window.crypto.subtle.exportKey('jwk', secretKey)
]);
</code></pre>


<p>The second promise is resolved when both of following two procedures are completed:</p>
<ul>
  <li>Encrypt file data <code>plaintext</code>
    <ul>
      <li>using <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt">encrypt()</a> of Web Crypto API;</li>
      <li>with 128-bit authentication tag length.</li>
    </ul>
  </li>
  <li>Export key
    <ul>
      <li>using <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey">exportKey()</a> of Web Crypto API;</li>
      <li>to the <a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-key-41">JSON Web Key</a> format.</li>
    </ul>
  </li>
</ul>

<h4 id="firefox_send_fileSender_upload_3">third Promise : Upload</h4>

<pre class="prettyprint"><code>      .then(([encrypted, keydata]) =&gt; {
        return new Promise((resolve, reject) =&gt; {
          const file = this.file;
          const fileId = arrayToHex(this.iv);
          const dataView = new DataView(encrypted);
          const blob = new Blob([dataView], { type: file.type });
          const fd = new FormData();
          fd.append('data', blob, file.name);

          // ****** snip (describe the next section...) ******

          xhr.open('post', '/upload', true);
          xhr.setRequestHeader(
            'X-File-Metadata',
            JSON.stringify({
              id: fileId,
              filename: encodeURIComponent(file.name)
            })
          );
          xhr.send(fd);
        });
});</code></pre>

<p>The third promise executes the following procedure:</p>
<ul>
  <li>Upload the file data <code>encrypted</code>
    <ul>
      <li>using XHR with Blob;</li>
      <li>with <code>X-File-Metadata</code> consisting of
        <ul>
          <li><code>id</code>: the file ID equivalent to <code>iv</code> (initial vector);</li>
          <li><code>filename</code>.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="firefox_send_fileSender_upload_4">return value: File Parameters</h4>

<pre class="prettyprint"><code>          xhr.onreadystatechange = () =&gt; {
            if (xhr.readyState === XMLHttpRequest.DONE) {
              if (xhr.status === 200) {
                const responseObj = JSON.parse(xhr.responseText);
                return resolve({
                  url: responseObj.url,
                  fileId: responseObj.id,
                  secretKey: keydata.k,
                  deleteToken: responseObj.delete
                });
              }
              reject(xhr.status);
            }
};</code></pre>

<p>The final promise returns following parameters:</p>
<ul>
  <li><code>url</code>: URL generated by server;</li>
  <li><code>fileId</code>: File ID generated by server (different than <code>iv</code> (initial vector) generated by client side);</li>
  <li><code>secretKey</code>: Secret key "K" exported by <a href="#firefox_send_fileSender_upload_2">the second promise</a> on client side;</li>
  <li><code>deleteToken</code>: Key token to delete the file generated by server.</li>
</ul>

<p>
Note: Download URL is <code>`${url}#${secretKey}`</code>.
See <a href="https://github.com/mozilla/send/blob/v1.1.0/frontend/src/upload.js">frontend/src/upload.js</a> for detail.
</p>

<h3 id="firefox_send_server_upload">Server side: POST /upload/</h3>

<p>
This clause describes "POST <code>/upload/</code>" handler defined in <a href="https://github.com/mozilla/send/blob/v1.1.0/server/server.js">server/server.js</a> (to store).
</p>

<pre class="prettyprint"><code>app.post('/upload', (req, res, next) =&gt; {
  const newId = crypto.randomBytes(5).toString('hex');

  // ***** snip *****

  meta.delete = crypto.randomBytes(10).toString('hex');
  req.pipe(req.busboy);

  req.busboy.on('file', async (fieldname, file, filename) =&gt; {
    try {
      await storage.set(newId, file, filename, meta);

      const protocol = conf.env === 'production' ? 'https' : req.protocol;
      const url = `${protocol}://${req.get('host')}/download/${newId}/`;
      res.json({
        url,
        delete: meta.delete,
        id: newId
      });
    } catch (e) {
      if (e.message === 'limit') {
        return res.sendStatus(413);
      }
      res.sendStatus(500);
    }
  });

  // ***** snip *****
});
</code></pre>

<p>Server stores:</p>
<ul>
  <li><code>newId</code>: File ID generated by server (different than <code>iv</code> (initial vector) generated by client side).</li>
  <li><code>file</code>: File data encrypted (by client side)</li>
  <li><code>meta</code>: <code>X-File-Metadata</code> consisting of
    <ul>
      <li><code>id</code>: the file ID equivalent to <code>iv</code> (initial vector) generated by client side;</li>
      <li><code>filename</code>;</li>
      <li><code>delete</code>: Key token to delete the file generated by server.</li>
    </ul>
  </li>
</ul>

<p>Server returns a response:</p>
<ul>
  <li>with JSON response body consisting of
    <ul>
      <li><code>url</code>: URL generated by server;</li>
      <li><code>delete</code>: Key token to delete the file generated by server.</li>
      <li><code>id</code>: File ID generated by server (different than <code>iv</code> (initial vector) generated by client side).</li>
    </ul>
  </li>
</ul>

<h3 id="firefox_send_fileReceiver_download">Client side: FileReceiver#download()</h3>

<p>
This clause describes <code>FileReceiver#download()</code> method defined in <a href="https://github.com/mozilla/send/blob/v1.1.0/frontend/src/fileReceiver.js">frontend/src/fileReceiver.js</a> (to download with client side decryption).
</p>

<h4 id="firefox_send_fileReceiver_download_1">first Promise : Import Key</h4>

<pre class="prettyprint"><code>window.crypto.subtle
      .importKey(
        'jwk',
        {
          kty: 'oct',
          k: location.hash.slice(1),
          alg: 'A128GCM',
          ext: true
        },
        {
          name: 'AES-GCM'
        },
        true,
        ['encrypt', 'decrypt']
)</code></pre>

<p>The first promise is resolved when following procedure is completed:</p>
<ul>
  <li>Import Key:
    <ul>
      <li>using <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey">importKey()</a> of Web Crypto API;</li>
      <li>from the URL hash (<code>#</code>) parameter;</li>
      <li>with a symmetric algorithm "AES-GCM" (AES in Galois/Counter Mode);</li>
      <li>with 128-bit key length.</li>
    </ul>
  </li>
</ul>

<h4 id="firefox_send_fileReceiver_download_2">second Promise : Download</h4>

<pre class="prettyprint"><code>      .then(key =&gt; {
        return new Promise((resolve, reject) =&gt; {
          const xhr = new XMLHttpRequest();

          // ***** snip *****

          xhr.onload = function(event) {
            // ***** snip *****

            const blob = new Blob([this.response]);
            const type = xhr.getResponseHeader('Content-Type');
            const meta = JSON.parse(xhr.getResponseHeader('X-File-Metadata'));
            const fileReader = new FileReader();
            fileReader.onload = function() {
              resolve([
                {
                  data: this.result,
                  filename: meta.filename,
                  type,
                  iv: meta.id
                },
                key
              ]);
            };

            fileReader.readAsArrayBuffer(blob);
          };

          xhr.open('get', '/assets' + location.pathname.slice(0, -1), true);
          xhr.responseType = 'blob';
          xhr.send();
        });
})</code></pre>

<p>The second promise is resolved when following procedure is completed:</p>
<ul>
  <li>Download file:
    <ul>
      <li>using XHR with Blob;</li>
      <li>returns parameter consisting of
        <ul>
          <li><code>data</code>: File data encrypted</li>
          <li><code>filename</code>;</li>
          <li><code>type</code>: the Content-Type of the HTTP response header;</li>
          <li><code>iv</code>: the file ID equivalent to <code>iv</code> (initial vector) generated by sender client side.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="firefox_send_fileReceiver_download_3">third Promise : Decrypt</h4>


<pre class="prettyprint"><code>      .then(([fdata, key]) =&gt; {
        this.emit('decrypting');
        return Promise.all([
          window.crypto.subtle
            .decrypt(
              {
                name: 'AES-GCM',
                iv: hexToArray(fdata.iv),
                tagLength: 128
              },
              key,
              fdata.data
            )
            .then(decrypted =&gt; {
              return Promise.resolve(decrypted);
            }),
          {
            name: decodeURIComponent(fdata.filename),
            type: fdata.type
          }
        ]);
});</code></pre>


<p>The third promise is resolved when following procedure is completed:</p>
<ul>
  <li>Encrypt file data <code>fdata.data</code>
    <ul>
      <li>using <a href="https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt">encrypt()</a> of Web Crypto API;</li>
      <li>with a symmetric algorithm "AES-GCM" (AES in Galois/Counter Mode);</li>
      <li>with following parameters:
        <ul>
          <li><code>iv</code>: the file ID equivalent to <code>iv</code> (initial vector) generated by sender client side;</li>
          <li><code>key</code>: Secret key "K" import by <a href="#firefox_send_fileReceiver_download_1">the first promise</a> on client side.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3>Conclusion</h3>

<div>
<figure style="display: block; margin: auto; text-align: center; font-size: smaller;">
{% asset_image_object_tag 201708-codereading_firefox_send.svg %}
<!--

digraph G {
  layout=dot;
  node [ shape=box, color=black ];

  subgraph cluster_Alice1 {
    style=filled;
    label = "Sender Client";
    color=pink
    node [style=filled,color=white];

    iv;
    secretKey [ fontcolor=red ];
    plaintext [ fontcolor=red ];
    filename;
    encrypted [ fontcolor=green ];

    secretKey -> encrypted;
    iv -> encrypted;
    plaintext -> encrypted;
  }

  subgraph cluster_Server {
    style=filled;
    label = "Server";
    color=orange
    node [style=filled,color=white];

    url;

    subgraph cluster_Storage {
      style=dashed;
      label = "Storage";
      color=blue;
      node [style=filled,color=white];

      newId;
      file [ fontcolor=green ];

      meta_id [ label="meta.id" ];
      meta_filename [ label="meta.filename" ];
      meta_delete [ label="meta.delete" ];
    }
  }

  subgraph cluster_Alice2 {
    style=filled;
    label = "Sender Client";
    color=pink
    node [style=filled,color=white];

    url_alice2 [ label = "url" ];
    fileId;
    secretKey_alice2 [ label = "secretKey", fontcolor=red ];
    deleteToken;
  }

  subgraph cluster_DL {
    style=filled;
    label = "Download URL";
    color=lightgray;
    node [style=filled,color=white];

    DL_path [ label="https://xxx/yyy" ];
    DL_hash [ label="#zzz", fontcolor=red ];
  }

  subgraph cluster_Bob {
    style=filled;
    label = "Receiver Client";
    color=lightblue;
    node [style=filled,color=white];

    key [ fontcolor=red ];
    url_bob [ label = "url" ];
    data  [ fontcolor=green ];
    decrypted  [ fontcolor=red ];
    iv_bob [ label = "iv" ];
    filename_bob [ label = "filename" ];
    key -> decrypted;
    iv_bob -> decrypted;
    data -> decrypted;
    filename_bob;
  }

  encrypted -> file [ weight=20 ];
  iv -> meta_id [ weight=20 ];
  filename -> meta_filename [ weight=20 ];
  
  newId -> url [ weight=20 ];
  
  url -> url_alice2 [ weight=20 ];
  secretKey -> secretKey_alice2 [ weight=20 ];
  meta_delete -> deleteToken;
  newId -> fileId;

  url_alice2 -> DL_path -> url_bob [ weight=20 ];
  secretKey_alice2 -> DL_hash -> key [ weight=20 ];
  file -> data [ weight=20 ];
  meta_id -> iv_bob [ weight=20 ];
  meta_filename -> filename_bob [ weight=20 ];
}

-->
<figcaption>Parameter Analysis</figcaption>
</figure>
</div>

{{ tldr }}

<h3>References</h3>

<ul>
  <li><a href="https://send.firefox.com/">Firefox Send</a>, Firefox Test Pilot</li>
  <li><a href="https://github.com/mozilla/send">mozilla/send</a>, <a href="https://github.com/mozilla/send/tree/v1.1.0">v1.1.0</a>, Github</li>
  <li>"<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API">Web Crypt API</a>", MDN</li>
  <li>N.Nguyen, "<a href="https://blog.mozilla.org/blog/2017/08/01/new-test-pilot-experiments/">New Test Pilot Experiments Available Today</a>, The Mozilla Blog, Aug 1 2017</li>
</ul>
